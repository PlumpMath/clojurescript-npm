#!/usr/bin/env node
var path = require('path');
var fs   = require('fs');
var lib  = path.join(path.dirname(fs.realpathSync(__filename)), '../lib');
var readline = require('readline');

var cljs = require(lib + '/clojurescript');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

var input = "";

String.prototype.attribute = function(attr, match) {
  return this.replace(match, "\x1b[" + attr + "m$1\x1b[0m");
}


function prompt(p) {
  var promptString = p || cljs.eval("(str *ns*)") + "=> ";
  rl.setPrompt(promptString);
  rl.prompt();
}

rl.on('line', (cmd) => {
  input += cmd + "\n";
  if(cmd.length > 0 && parenthesesAreBalanced(input)) {
    var x = cljs.eval(input);
    input = "";
    
    var result = cljs.context.cljs.core.pr_str(x)
                    .attribute("33", /(\b(\d+\.?\d*)\b)/g)
                    .attribute("37;1", /(:\w+)/g)
                    .attribute("32", /(\"[^\"]+")/g)
                    .attribute("36", /(#\w+)/g);
    console.log(result);
    prompt();
  } else {
    prompt("... ");
  }
});

rl.on('close', () => {
  process.exit(0);
});

prompt();

// http://codereview.stackexchange.com/questions/45991/balanced-parentheses
function parenthesesAreBalanced(s)
{
  var parentheses = "[]{}()",
    stack = [], //Parentheses stack
    i, //Index in the string
    c; //Character in the string

  for (i = 0; c = s[i++];)
  {
    var bracePosition = parentheses.indexOf(c),
      braceType;
    //~ is truthy for any number but -1
    if (!~bracePosition)
      continue;

    braceType = bracePosition % 2 ? 'closed' : 'open';

    if (braceType === 'closed')
    {
      //If there is no open parenthese at all, return false OR
      //if the opening parenthese does not match ( they should be neighbours )
      if (!stack.length || parentheses.indexOf(stack.pop()) != bracePosition - 1)
        return false;
    }
    else
    {
      stack.push(c);
    }
  }
  //If anything is left on the stack <- not balanced
  return !stack.length;
}